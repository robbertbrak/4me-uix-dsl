@top Root { expression }

@precedence {
  cf,
  member,
  call,
  rel @left,
  equal @left,
  in @left,
  and @left,
  or @left
}

expression {
  expressionNoCF |
  CustomFieldExpression
}

expressionNoCF {
  Number |
  String |
  VariableName |
  ArrayExpression |
  ParenthesizedExpression |
  BinaryExpression |
  CallExpression { expressionNoCF !call ArgList }
}

ParenthesizedExpression { "(" expression ")" }

ArrayExpression {
  "[" commaSep1<"..."? expression | ""> ~destructure "]"
}

CustomFieldExpression {
  !cf kw<"cf"> "." PropertyName (("." kw<"value">)? | "." kw<"options"> "." PropertyName)
}

MemberExpression {
  expressionNoCF !member "." PropertyName
}

BinaryExpression {
  expression !rel (LessThan | CompareOp<"<=" | ">" "="?>) expression |
  expression !equal CompareOp<"==" | "!="> expression |
  expression !in CompareOp<"in" | "not in"> expression |
  expression !and LogicOp<"&&"> expression |
  expression !or LogicOp<"||" | "??"> expression

}

ArgList {
  "(" commaSep<"..."? expression> ")"
}

VariableName { identifier ~arrow }

PropertyName { word }

PropertyDefinition { word }

PrivatePropertyName { privateIdentifier }

PrivatePropertyDefinition { privateIdentifier }

commaSep<content> {
  "" | content ("," content?)*
}

commaSep1<content> {
  content ("," content)*
}

kw<term> { @specialize[@name={term}]<identifier, term> }

@skip {} {
  String {
    '"' (stringContentDouble | Escape)* ('"' | "\n") |
    "'" (stringContentSingle | Escape)* ("'" | "\n")
  }

  BlockComment { "/*" (blockCommentContent | blockCommentNewline)* blockCommentEnd }
}

@skip { spaces | newline | LineComment | BlockComment }

@local tokens {
  blockCommentEnd { "*/" }
  blockCommentNewline { "\n" }
  @else blockCommentContent
}

@tokens {
  spaces[@export] { $[\u0009 \u000b\u00a0\u1680\u2000-\u200a\u202f\u205f\u3000\ufeff]+ }
  newline[@export] { $[\r\n\u2028\u2029] }

  LineComment { "//" ![\n]* }

  Hashbang { "#!" ![\n]* }

  divide[@name=ArithOp] { "/" }

  @precedence { "/*", LineComment, divide }

  @precedence { "/*", LineComment, RegExp }

  identifierChar { @asciiLetter | $[-_$\u{a1}-\u{10ffff}] }

  word { identifierChar (identifierChar | @digit)* }

  identifier { word }

  privateIdentifier { "#" word }

  @precedence { spaces, newline, identifier }

  @precedence { spaces, newline, JSXIdentifier, JSXLowerIdentifier }

  @precedence { spaces, newline, word }

  hex { @digit | $[a-fA-F] }

  Number {
    (@digit ("_" | @digit)* ("." ("_" | @digit)*)? | "." @digit ("_" | @digit)*)
      (("e" | "E") ("+" | "-")? ("_" | @digit)+)? |
    @digit ("_" | @digit)* "n" |
    "0x" (hex | "_")+ "n"? |
    "0b" $[01_]+ "n"? |
    "0o" $[0-7_]+ "n"?
  }

  @precedence { Number "." }

  Escape {
    "\\" ("x" hex hex | "u" ("{" hex+ "}" | hex hex hex hex) | ![xu])
  }

  stringContentSingle { ![\\\n']+ }

  stringContentDouble { ![\\\n"]+ }

  templateStart { "`" }

  InterpolationEnd[openedBy=InterpolationStart] { "}" }

  ArithOp<expr> { expr }
  LogicOp<expr> { expr }
  BitOp<expr> { expr }
  CompareOp<expr> { expr }
  UpdateOp<expr> { expr }

  @precedence { "*", ArithOp }

  RegExp { "/" (![/\\\n[] | "\\" ![\n] | "[" (![\n\\\]] | "\\" ![\n])* "]")+ ("/" $[gimsuy]*)? }

  LessThan[@name=CompareOp] { "<" }

  "="[@name=Equals]
  "..."[@name=Spread]
  "=>"[@name=Arrow]

  "(" ")" "[" "]" "{" "}" ">"

  "?." "." "," ";" ":" "@"
}
